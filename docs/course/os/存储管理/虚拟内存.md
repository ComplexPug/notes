# 虚拟内存
是把它切碎,分成一个个小单元,比如4KB大小,他们称为一页或页面,
其中只有一部分的页面会在内存中,当CPU需要访问的地址不在内存中的页面中时,
可以从磁盘中加载对应的部分,同时内存不够时,也可以把长期不访问的页面保存到
磁盘中,然后删除内存中的部分,这个做法称为虚拟内存。

对程序来说，他所看到的内存就是连续的。

访问内存的时候，会有mmu（memory management unit）转换地址

会有页表来帮助访问。
虚拟地址 -> 物理地址的映射

页表里面只需要存物理地址的映射即可，虚拟地址通过下标访问。页表里面只需要存物理地址的映射即可，虚拟地址通过下标访问。
如果是单级页表，4GB内存，有4GB/4KB=2^20个页，需要2^20*4B = 4MB内存的页表

每一个程序如果都创建一个4MB页表，那占用内存就太多了。
需要引入多级页表
32位是两级页表，64位是四级页表（当然并不绝对）
为什么减少了内存占用，根据局部性原理，二级页表并不总是要一开始就创建。
而一级页表必须一开始就申请连续4kb内存。
注意64位电脑现在的地址长度是48位的，因为64位太大，对地址翻译，cache，TLB有浪费。
四级页表的结构是9+9+9+9+12 256TB

虚拟内存如果没有映射到物理内存会发生缺页，切换到内核态，分配物理内存。

TLB技术加速MMU查询Translation Lookaside Buffer
页表缓存、转址旁路缓存、快表

内存指针是64位的，但高12位需要相等，全为0或1。

0000000000000000 - 00007fffffffffff(128TB)为用户空间

ffff800000000000 - ffffffffffffffff(128TB)为内核空间
## 关于一个进程的内存分布
移步进程管理，结合观看吧

## Problem
- [x] 页表在哪里，在内核态内存里面，但用户态使用的时候并不需要转到内核态，因为访问内存是mmu干的事情，当然缺页的时候需要转换内核态。

## link
[blog](https://lishiwen4.github.io/linux/linux-process-memory-location)