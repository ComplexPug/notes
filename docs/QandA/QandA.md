- [ ] tcp udp的端口相同问题
- [ ] 开机事项
- [ ] 引用和指针的问题
- [ ] 什么是反向代理ReverseProxy
反向代理是代理服务器。位于服务端的组网内，可以隐藏服务端的网络信息。让服务看起来只有一个服务端（即反向代理服务器）。
正向代理是代理客户端。位于，可以隐藏服务端的网络信息。让服务看起来只有一个服务端（即反向代理服务器）。
网上有一种区分是按照intetnet之前还是之后，感觉不恰当，可以 TODO 再思考了。
- [ ] tcp四次挥手为什么是四次
可能是双端通信等对方还没发送完数据或者处理接收的数据。
1. Fin
2. 接受Fin，回一个ack
3. 接收方处理完毕，回一个Fin
4. 发送方回ack，等2msl


- [x] 盖尔定律(Gall's Law)

从头开始设计的复杂系统根本不切实可行，无法修修补补让它切实可行。 你必须由一个切实可行的简单系统重新开始。 盖尔定律说明了设计高度复杂的系统很可能会失败。 它们很难一蹴而就，更多是从简单的系统逐渐演变而来。

- [ ] 2. lazyvim在使用tmux的时候下划线效果失效

这应该是tmux的使用配置的问题

- [ ] 3. dsr-mp.local 还有localhost是什么？mysql连接失败和localhost有关吗？

- [x] 4. 看网络RFC文档和jyy的讲课，出于对美好事物的追求，很好奇他们的编写工具是什么，如何做到格式转换的？

- [ ] 5. 24种设计模式正宗吗？为什么我感觉有些设计模式处处都有很常见，那也要说吗？

- [x] 6. 代码分类

大部分代码：基本都在边界检查和一些特殊处理上，主要为了产品的严谨安全可靠等，占用时间少。

小部分代码：数据结构，逻辑处理，占用了较长的时间。

关键代码：少但实际执行时间占用了大部分。

- [ ] 7. 写everything is file的文章

- [x] 8. 《程序员的底层思维》的简单笔记和理解

一本关于软件设计和思维的书，有很多设计模式和一些思想，确实感觉还算有知识能看的一本书。

## 量化思维

OKR

## 工具化思维

自动脚本演变为DevOps，ORM工具等。

## 简单思维

简单化产品，简单设计并保持 Unix API

## 分治思维

把大象放到冰箱分几步？

分解+治理+合并，不管是分布式，还是数据结构，还是解决实际问题，都会有分治的思想。

就看了这么多，然后针对码农的还需要的素养就是沟通表达能力（包含传递信息，吹牛，报告，和leader和员工的信任关系等），不过这个好像全职业通用。

技术和业务的话，可能是职业的特性，但如果这两个和牛当然通用技能可以弱一点，不过程序员确实对一些社恐级的人还算接受了。

- [x] 9. 为什么接口通常只用一个实现类却还要写呢？
  
1. 约定俗成，类似协议一样，不然就是不通用，不通用就会被抛弃。

2. 统一规范。需要的时候写，不需要的时候不写，那就乱了。

~~3. 解耦合，但这不是问题的关键。~~

看起来1和2类似，但其实是不一样的。第一条是调用者角度考虑，第二条是不同代码间考虑。

- [x] 10. vim读取文件是会全部读取到内存里面的，所以不要打开大文件，如果要看日志可以用less等别的工具

- [x] 11. vim的光标

之前写的时候总是一个方框，不像neovim一样插入是|，其他模式是方框，今天修改终端config的时候调整命令窗口的光标，发现他vim是使用的terminal的光标图标的。

- [x] 12. macos的浅色terminal

亮度够用起来确实不错。

- [x] 13. 虚拟内存和线段树

动态开点线段书和虚拟内存页表一样。

- [ ] 14. 鲁班锁

知识没学完的时候并不知道有什么用，当你学完了或者有一天明白了，发现它的作用了。就像拼一些卡扣一样，一开始是形变的，用力卡进最后一块后，十分自然。

- [ ] 15. 记忆

记忆是什么形式的，首先肯定不是原始场景，还有会对很多无用信息的忽略，可能一般记忆本身就不熟很复杂？感觉大部分信息还是有的。感觉也不想是特征提取

- [ ] 16. 纠正

为什么这么做，是因为之前没做的时候发生了错误而修正的原因.
bug靠测试纠正，产品靠用户纠正，人类靠历史纠正，（简单）物理靠实验纠正。

- [ ] 大模型的作用

1. 探索未知知识
2. 超级函数或者通用函数，具有一点能动性的简单对话
3. 替代人做重复简单工作（可以通过脚本的方式，比计算机高一层次）
