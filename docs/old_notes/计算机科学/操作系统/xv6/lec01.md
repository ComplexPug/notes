# Lecture 01
## 前置
搭建环境，又复习了一下gdb。
## test xv6 in qemu
感觉十分简单的os，有一些小工具ls，grep，管道等。
## 1.3 Pipes
    管道是一个小的内核缓冲区，作为一对文件描述符暴露给进程，一个用于读，一个用于
写。将数据写入管道的一端就可以从管道的另一端读取数据。管道为进程提供了一种通信方
式。
```c
int p[2];
pipe(p);
```

常见的shell命令比如`ls|wc,cat xx|sort|uniq` 就是前面的标准输出通过管道重定向到后面的标准输入。
然后就是shell中的管道是没有先后顺序的，因为是并发执行的`sleep 10 | echo hi`。

## 1.7 Shell
文件描述符本质上对应了内核中的一个表单数据。内核维护了每个运行进程的状态，内核会为每一个运行进程保存一个表单，表单的key是文件描述符。这个表单让内核知道，每个文件描述符对应的实际内容是什么。这里比较关键的点是，每个进程都有自己独立的文件描述符空间，所以如果运行了两个不同的程序，对应两个不同的进程，如果它们都打开一个文件，它们或许可以得到相同数字的文件描述符，但是因为内核为每个进程都维护了一个独立的文件描述符空间，这里相同数字的文件描述符可能会对应到不同的文件。

- [ ] 问题：为什么这样设计呢。

## 1.8 fork系统调用
进程调用fork()。fork()出来的进程返回0，另一个返回PID。
新进程从fork()开始执行。

- [ ] 学生提问：fork产生的子进程是不是总是与父进程是一样的？它们有可能不一样吗？
Robert教授：在XV6中，除了fork的返回值，两个进程是一样的。两个进程的指令是一样的，数据是一样的，栈是一样的，同时，两个进程又有各自独立的地址空间，它们都认为自己的内存从0开始增长，但这里是不同的内存。 在一个更加复杂的操作系统，有一些细节我们现在并不关心，这些细节偶尔会导致父子进程不一致，但是在XV6中，父子进程除了fork的返回值，其他都是一样的。除了内存是一样的以外，文件描述符的表单也从父进程拷贝到子进程。所以如果父进程打开了一个文件，子进程可以看到同一个文件描述符，尽管子进程看到的是一个文件描述符的表单的拷贝。除了拷贝内存以外，fork还会拷贝文件描述符表单这一点还挺重要的，我们接下来会看到。
- [ ] 对上面一个问题：文件描述符的拷贝和文件描述符又有什么区别呢。那他们的PID不是不一样吗
当然不是，创造新的进程pid肯定不一样，但是文件描述符是拷贝的，这不就是上面的学生提问吗。
- [ ] 对于pcb，他是在哪里呢，就是xv6的proc吗，他又放在内核的哪个内存部分呢

### 对于fork和exec
有人说他们按理说是应该在一起执行的，比如`forkexec`命令，之所以分开是因为在`fork`之后，`exec`之前子进程的io重定向。
否则就需要在父进程中修改fd了。

#### 对于fork
```cpp
#include <bits/stdc++.h>
#include <sys/wait.h>
using namespace std;
int main() {
    for (int i = 1; i <= 2; i++) {
        fork();
        printf("hello world\n");fflush(stdout);
    }
}
```
- [ ] 发现一个很有意思的东西，printf得强制刷新缓冲区，不然会输出多

### 关于fd的分配
close 系统调用会释放一个文件描述符，使它可以被以后的 open、pipe 或 dup 系统调
用所重用（见下文）。新分配的文件描述符总是当前进程中最小的未使用描述符。

> 测试：如何将stderror重定向到stdout
dup2(stdout,stderror)
或者
close+dup


## 1.9 exec, wait系统调用

## 1.10 I/O Redirect

## Lab1
`fprintf(2,"hello")`:输出到指定fd上，`printf`就是默认为1了。
### sleep.c
直接调用sleep即可
- [ ] 为什么sys_sleep这里变成了sleep了呢？
user.h重命名了一下 
## Problems
- [ ] 编译器是如何处理系统调用的（如open，read/write file）
调用相关的指令转到内核态处理,`xcall`

## link
XV6-Chinese-2020.pdf